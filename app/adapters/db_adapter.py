import datetimeimport sqlite3from app.adapters.yandex import get_yandex_weatherfrom app.settings import PARSED_CONFIGclass WeatherParser(object):    """        Class for working with DataBase (sQlite)    """    user_field = ["id", "user_name", "user_id", "date_last"]    log_field = ["id", "user_id", "date_time", "city", "is_success", "message"]    city_field = ["id", "name_ru", "name_en"]    user_city_field = ["id", "user_id", "date_last", "city"]    def __init__(self):        # Создаем подключение к базе данных (файл my_database.db будет создан)        # Устанавливаем соединение с базой данных        connection = sqlite3.connect(PARSED_CONFIG.sqlite_db)        cursor = connection.cursor()        # Создаем таблицу Users        cursor.execute('''            CREATE TABLE IF NOT EXISTS User (                id INTEGER PRIMARY KEY,                user_name TEXT NOT NULL,                user_id INTEGER,                date_last timestamp            )        '''        )        # User-defined type        sqlite3.register_adapter(bool, int)        sqlite3.register_converter("BOOL", lambda v: bool(int(v)))        # Создаем таблицу Log        cursor.execute('''            CREATE TABLE IF NOT EXISTS Log (                id INTEGER PRIMARY KEY,                user_id INTEGER,                date_time timestamp,                city TEXT NOT NULL,                is_success BOOL,                message TEXT            )        '''                       )        # Создаем таблицу City        cursor.execute('''            CREATE TABLE IF NOT EXISTS City (                id INTEGER PRIMARY KEY,                name_ru TEXT NOT NULL,                name_en TEXT NOT NULL            )        '''                       )        # Создаем таблицу User_City        cursor.execute('''            CREATE TABLE IF NOT EXISTS User_City (                id INTEGER PRIMARY KEY,                user_id INTEGER,                date_last timestamp,                city TEXT NOT NULL            )        '''                       )        # Сохраняем изменения и закрываем соединение        connection.commit()        connection.close()    async def user_add(self, user_id: int, user_name: str = "") -> dict:        user_old = await self.user_get(self, user_id)        if user_old:            await self.user_update(self, user_id, user_name)        else:            connection = sqlite3.connect(PARSED_CONFIG.sqlite_db)            cursor = connection.cursor()            cursor.execute(f'INSERT INTO User (user_name, user_id, date_last) '                           f'VALUES ("{user_name}", {user_id}, "{datetime.datetime.now()}")')            connection.commit()            connection.close()        return await self.user_get(self, user_id)    async def user_get(self, user_id: int) -> dict:        connection = sqlite3.connect(PARSED_CONFIG.sqlite_db)        cursor = connection.cursor()        fields = ",".join(self.user_field)        cursor.execute(f'SELECT {fields} FROM User WHERE user_id == {user_id}')        result = cursor.fetchone()        connection.close()        return {key: val for key, val in zip(self.user_field, result)} if result else None    async def user_update(self, user_id: int, user_name: str = None) -> dict:        user_old = await self.user_get(self, user_id)        if user_old:            user_name = user_name if user_name else user_old["user_name"]            connection = sqlite3.connect(PARSED_CONFIG.sqlite_db)            cursor = connection.cursor()            # Обновляем пользователя            cursor.execute(                f"""                    UPDATE User                    SET user_name = "{user_name}", date_last = "{datetime.datetime.now()}"                    WHERE user_id = {user_id}                """            )            # Сохраняем изменения и закрываем соединение            connection.commit()            connection.close()        else:            await self.user_add(user_id, (user_name or ""))        return await self.user_get(self, user_id)    @staticmethod    async def log_add(user_id: int, city: str = "", is_success: bool = True, message: str = ""):        connection = sqlite3.connect(PARSED_CONFIG.sqlite_db)        connection.execute('INSERT INTO Log (user_id, date_time, city, is_success, message) VALUES (?, ?, ?, ?, ?)',                       (user_id, datetime.datetime.now(), city, is_success, message))        connection.commit()        connection.close()    async def log_get(self, limit: int = 10) -> list[dict]:        connection = sqlite3.connect(PARSED_CONFIG.sqlite_db)        cursor = connection.cursor()        fields = ",".join(self.log_field)        cursor.execute(f'SELECT {fields} FROM Log ORDER BY id DESC LIMIT {limit}')        result = cursor.fetchall()        connection.close()        return [{key: not bool(val) if key.startswith("is_") else val for key, val in zip(self.log_field, log)} for log in result] if result else None    @staticmethod    async def city_add(name_ru: str, name_en: str):        connection = sqlite3.connect(PARSED_CONFIG.sqlite_db)        cursor = connection.cursor()        cursor.execute(f'INSERT INTO City (name_ru, name_en) VALUES ("{name_ru}", "{name_en}")')        connection.commit()        connection.close()    async def city_get(self, name_ru: str = "") -> list[dict]:        connection = sqlite3.connect(PARSED_CONFIG.sqlite_db)        cursor = connection.cursor()        fields = ",".join(self.city_field)        cursor.execute(f'SELECT {fields} FROM City WHERE name_ru LIKE "%{name_ru.lower()}%"')        result = cursor.fetchall()        connection.close()        print(f"city_get {name_ru}")        return [{key: val for key, val in zip(self.city_field, city)} for city in result] if result else None    async def user_city_add_or_update(self, user_id: int, city: str):        connection = sqlite3.connect(PARSED_CONFIG.sqlite_db)        cursor = connection.cursor()        fields = ",".join(self.user_city_field)        sql_command = f'SELECT {fields} FROM User_City WHERE user_id == {user_id} AND city == "{city}"'        cursor.execute(sql_command)        result = cursor.fetchone()        if result:            sql_command = (f'UPDATE User_City SET date_last = "{datetime.datetime.now()}" '                           f'WHERE user_id == {user_id} AND city == "{city}"')        else:            sql_command = (f'INSERT INTO User_City (user_id, city, date_last) '                           f'VALUES ({user_id}, "{city}", "{datetime.datetime.now()}")')        cursor.execute(sql_command)        connection.commit()        connection.close()    @staticmethod    async def user_city_get(user_id: int) -> list[dict]:        connection = sqlite3.connect(PARSED_CONFIG.sqlite_db)        cursor = connection.cursor()        fields_list = ["user_id", "name_en", "name_ru"]        fields = ", ".join(fields_list)        sql_command = (f'SELECT {fields} FROM User_City u JOIN City c ON u.city == c.name_en '                       f'WHERE user_id == {user_id} ORDER BY date_last DESC LIMIT 10')        cursor.execute(sql_command)        result = cursor.fetchall()        connection.close()        return [{key: val for key, val in zip(fields_list, city)} for city in result] if result else None    async def weather_get(self, user_id: int, city: str) -> dict:        result = await get_yandex_weather(city.lower())        await self.log_add(user_id, city, result["is_error"], result["message"])        if not result["is_error"]:            await self.user_city_add_or_update(self, user_id, city)        return result